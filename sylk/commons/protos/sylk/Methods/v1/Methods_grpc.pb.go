// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v4.23.1
// source: sylk/Methods/v1/Methods.proto

package v1

import (
	context "context"
	v1 "github.com/sylk-build/sylk-core/services/protos/sylk/SylkApi/v1"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// MethodsClient is the client API for Methods service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MethodsClient interface {
	// [sylk] - None
	CreateMethod(ctx context.Context, in *v1.CreateMethodRequest, opts ...grpc.CallOption) (*v1.CreateMethodResponse, error)
	// [sylk] - None
	GetMethod(ctx context.Context, in *v1.GetMethodRequest, opts ...grpc.CallOption) (*v1.GetMethodResponse, error)
	// [sylk] - None
	DeleteMethod(ctx context.Context, in *v1.DeleteMethodRequest, opts ...grpc.CallOption) (*v1.DeleteMethodResponse, error)
	// [sylk] - None
	UpdateMethod(ctx context.Context, in *v1.UpdateMethodRequest, opts ...grpc.CallOption) (*v1.UpdateMethodResponse, error)
}

type methodsClient struct {
	cc grpc.ClientConnInterface
}

func NewMethodsClient(cc grpc.ClientConnInterface) MethodsClient {
	return &methodsClient{cc}
}

func (c *methodsClient) CreateMethod(ctx context.Context, in *v1.CreateMethodRequest, opts ...grpc.CallOption) (*v1.CreateMethodResponse, error) {
	out := new(v1.CreateMethodResponse)
	err := c.cc.Invoke(ctx, "/Methods/CreateMethod", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *methodsClient) GetMethod(ctx context.Context, in *v1.GetMethodRequest, opts ...grpc.CallOption) (*v1.GetMethodResponse, error) {
	out := new(v1.GetMethodResponse)
	err := c.cc.Invoke(ctx, "/Methods/GetMethod", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *methodsClient) DeleteMethod(ctx context.Context, in *v1.DeleteMethodRequest, opts ...grpc.CallOption) (*v1.DeleteMethodResponse, error) {
	out := new(v1.DeleteMethodResponse)
	err := c.cc.Invoke(ctx, "/Methods/DeleteMethod", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *methodsClient) UpdateMethod(ctx context.Context, in *v1.UpdateMethodRequest, opts ...grpc.CallOption) (*v1.UpdateMethodResponse, error) {
	out := new(v1.UpdateMethodResponse)
	err := c.cc.Invoke(ctx, "/Methods/UpdateMethod", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MethodsServer is the server API for Methods service.
// All implementations must embed UnimplementedMethodsServer
// for forward compatibility
type MethodsServer interface {
	// [sylk] - None
	CreateMethod(context.Context, *v1.CreateMethodRequest) (*v1.CreateMethodResponse, error)
	// [sylk] - None
	GetMethod(context.Context, *v1.GetMethodRequest) (*v1.GetMethodResponse, error)
	// [sylk] - None
	DeleteMethod(context.Context, *v1.DeleteMethodRequest) (*v1.DeleteMethodResponse, error)
	// [sylk] - None
	UpdateMethod(context.Context, *v1.UpdateMethodRequest) (*v1.UpdateMethodResponse, error)
	mustEmbedUnimplementedMethodsServer()
}

// UnimplementedMethodsServer must be embedded to have forward compatible implementations.
type UnimplementedMethodsServer struct {
}

func (UnimplementedMethodsServer) CreateMethod(context.Context, *v1.CreateMethodRequest) (*v1.CreateMethodResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateMethod not implemented")
}
func (UnimplementedMethodsServer) GetMethod(context.Context, *v1.GetMethodRequest) (*v1.GetMethodResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMethod not implemented")
}
func (UnimplementedMethodsServer) DeleteMethod(context.Context, *v1.DeleteMethodRequest) (*v1.DeleteMethodResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteMethod not implemented")
}
func (UnimplementedMethodsServer) UpdateMethod(context.Context, *v1.UpdateMethodRequest) (*v1.UpdateMethodResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateMethod not implemented")
}
func (UnimplementedMethodsServer) mustEmbedUnimplementedMethodsServer() {}

// UnsafeMethodsServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MethodsServer will
// result in compilation errors.
type UnsafeMethodsServer interface {
	mustEmbedUnimplementedMethodsServer()
}

func RegisterMethodsServer(s grpc.ServiceRegistrar, srv MethodsServer) {
	s.RegisterService(&Methods_ServiceDesc, srv)
}

func _Methods_CreateMethod_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.CreateMethodRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MethodsServer).CreateMethod(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Methods/CreateMethod",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MethodsServer).CreateMethod(ctx, req.(*v1.CreateMethodRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Methods_GetMethod_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.GetMethodRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MethodsServer).GetMethod(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Methods/GetMethod",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MethodsServer).GetMethod(ctx, req.(*v1.GetMethodRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Methods_DeleteMethod_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.DeleteMethodRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MethodsServer).DeleteMethod(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Methods/DeleteMethod",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MethodsServer).DeleteMethod(ctx, req.(*v1.DeleteMethodRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Methods_UpdateMethod_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.UpdateMethodRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MethodsServer).UpdateMethod(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Methods/UpdateMethod",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MethodsServer).UpdateMethod(ctx, req.(*v1.UpdateMethodRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Methods_ServiceDesc is the grpc.ServiceDesc for Methods service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Methods_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "Methods",
	HandlerType: (*MethodsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateMethod",
			Handler:    _Methods_CreateMethod_Handler,
		},
		{
			MethodName: "GetMethod",
			Handler:    _Methods_GetMethod_Handler,
		},
		{
			MethodName: "DeleteMethod",
			Handler:    _Methods_DeleteMethod_Handler,
		},
		{
			MethodName: "UpdateMethod",
			Handler:    _Methods_UpdateMethod_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "sylk/Methods/v1/Methods.proto",
}
